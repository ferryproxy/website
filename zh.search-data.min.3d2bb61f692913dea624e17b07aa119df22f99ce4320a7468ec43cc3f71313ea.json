[{"id":0,"href":"/zh/docs/roadmap/","title":"Roadmap","section":"Docs","content":"路线图 #  本文概述了Ferry作为一个项目的一些目标、非目标和未来的期望。  DONE #   通信加密 只使用 Ferryctl 来配置集群之间的服务映射，而不使用 Controller 支持多级代理  TODO #   支持完整的卸载自身和清理 监控状态，并显示在Hub的状态中 适配上下游生态 支持 mcs api 单个 Hub 支持多副本 Tunnel SSH-via-QUIC: Tunnel 之间的 ssh 协议使用 quic 替换 tcp, 在 IP 变化后无需重新连接, 预期更好的性能 支持任何设备主动连接并加入作为 Hub, 提供 SDK 和 Binary 支持两个无公网 IP 的 Hub 经过控制面撮合, 通过 UDP p2p 直连, 数据无需通过控制面 负载均衡 故障转移 就近访问 访问控制  IDEA #   提供流量和业务性能的视图 支持 Service 的 UDP  Suggesting #  如果我们遗漏了一些东西，让 Ferry 对你更有用，请让我们知道。 最好的方法是 提交一个 Issue，并包括关于你打算如何使用 Ferry 的信息。\n"},{"id":1,"href":"/zh/docs/user/examples/forward-listen/","title":"创建并转发集群的 Service 端口到本地端口","section":"Docs","content":"创建并转发集群的 Service 端口到本地端口 #  准备工作 #   准备工作\n创建并转发集群的 Service 端口到本地端口 #  ferryctl local forward listen \u0026lt;remote service port\u0026gt; \u0026lt;local address port\u0026gt;  ferryctl local forward listen local.test.svc:80 127.0.0.1:28080 所有在集群里 web-0.test.svc:80 端口的访问都会被转发到本地的 127.0.0.1:28080 端口\n 示例代码\n"},{"id":2,"href":"/zh/docs/user/with-service-mesh/","title":"和服务网格一起使用","section":"Docs","content":"和服务网格一起使用 #  通过在 Istio 中验证, 只要不往 ferry-tunnel 中注入 Sidecar, Ferry 可以完美适配\n"},{"id":3,"href":"/zh/docs/user/examples/manual/","title":"手动映射服务","section":"Docs","content":"手动映射服务 #  为什么需要这个 #  在某些集群不可达的场景里, 需要提前暴露数据面的 apiserver 地址给控制面, 这样控制面就可以访问数据面的 apiserver\n由该功能配置的路由规则不受 ferry-controller 的控制\n准备工作 #   准备工作\n手动映射服务 #  定义从其他集群导出某一服务 #  ferryctl local manual import --reachable=true \u0026#34;--tunnel-address=${HOST_IP}:31000\u0026#34; --export-host-port=web-1.test.svc:8080 --import-service-name=web-1-8080 这条命令描述将导出服务集群的 web-1.test.svc:8080 服务映射到当前集群的 web-1-8080.ferry-tunnel-system:8080 服务\n--reachable=true 当前集群是否可以达到 --tunnel-address 当前集群如果可以达到的情况下 Tunnel 的地址 --export-host-port 从其他集群导出的服务端口 --import-service-name 当前集群从其他集群导出的服务建立的映射服务 (默认在 ferry-tunnel-system 命名空间下)  需要 握手\n快速在本地拉起测试环境 #  如果你没有可以测试集群又想快速尝试可以按照下面的流程\n要求: Docker, Kind, Go\ngit clone https://github.com/ferryproxy/ferry go install ./cmd/ferryctl ./test/hack/start-environment.sh manual 将会使用 Kind 启动两个集群, 并配置好两个集群之间的服务路由规则\n 环境状况\n 示例代码\n"},{"id":4,"href":"/zh/docs/principle/","title":"技术原理","section":"Docs","content":"技术原理 #  通信和穿透 #  Ferry-Tunnel 之间使用 ssh 协议的能力实现通信和穿透\n主要使用以下能力\n  direct-tcpip  tcpip-forward  direct-streamlocal  streamlocal-forward  核心就两点\n 监听本地一个端口, 连接上对端的 Ferry-Tunnel, 并通过其转发所有连接 连接上对端的 Ferry-Tunnel 并监听一个端口, 转发监听端口的连接到本地  服务发现 #  每一个导出的服务端口都会在导入的集群中的 Ferry-Tunnel 分配一个端口\nFerry 会在导入的集群创建 Headless Service 指向本集群的 Ferry-Tunnel 对应服务的端口\n"},{"id":5,"href":"/zh/docs/user/examples/control-plane-unreachable/","title":"控制面集群不可达","section":"Docs","content":"控制面集群不可达 #  准备至少两个集群才能做演示\n可以是一个节点的集群或者 Kind 起的集群但最少也要两个\n 准备工作 #   准备工作\n初始化控制面集群 #  # 在控制面集群执行 ferryctl control-plane init --control-plane-reachable=false --control-plane-reachable 指定控制面集群是否可达  加入数据面集群 #  向控制面集群声明哪个数据面集群需要加入 #  # 在控制面集群执行，预连接其他数据平集群 ferryctl control-plane join cluster-1 \u0026#34;--data-plane-tunnel-address=${HOST_IP}:31001\u0026#34; --control-plane-reachable=false --data-plane-tunnel-address 指定对于控制面集群来说数据面集群 Tunnel 的地址 --control-plane-reachable 指定控制面集群是否可达  需要 握手\n完成握手 #  然后可以在控制面集群查看这个数据面集群了\nkubectl get hub.traffic.ferryproxy.io -n ferry-system 快速在本地拉起测试环境 #  如果你没有可以测试集群又想快速尝试可以按照下面的流程\n要求: Docker, Kind, Go\ngit clone https://github.com/ferryproxy/ferry go install ./cmd/ferryctl ./test/hack/start-environment.sh control-plane-unreachable 将会使用 Kind 启动两个集群, 并在控制面集群安装好 ferry-controller, 但是没有配置路由规则\n 环境状况\n在控制面集群配置路由规则\n# 把 cluster-1 的 web-1.test.svc 映射到 control-plane 的 web-1.test.svc # 把 control-plane 的 web-0.test.svc 映射到 cluster-1 的 web-0.test.svc apiVersion: traffic.ferryproxy.io/v1alpha2 kind: RoutePolicy metadata: name: ferry-test namespace: ferry-system spec: exports: - hubName: cluster-1 service: namespace: test name: web-1 - hubName: control-plane service: namespace: test name: web-0 imports: - hubName: cluster-1 - hubName: control-plane # 进入 control-plane 的容器里 去 请求 cluster-1 映射过来的 servuce kubectl --context=kind-ferry-test-control-plane exec -it svc/web-0 -n test -- wget -O - web-1 # 进入 cluster-1 的容器里 去 请求 control-plane 映射过来的 servuce kubectl --context=kind-ferry-test-cluster-1 exec -it svc/web-1 -n test -- wget -O - web-0  示例代码\n"},{"id":6,"href":"/zh/docs/user/handshake/","title":"握手","section":"Docs","content":"握手 #  部分命令需要通知两个集群这个行为称之为握手\n自动 #  如果能同时连上两个集群\nKUBECONFIG 指定当前集群的 kubeconfig 文件\nFERRY_PEER_KUBECONFIG 指定对端集群的 kubeconfig 文件\n手动 #  如果不能同时连上两个集群\n首次响应 #  在当前集群的命令执行后, 会响应一个命令复制到对端集群执行\n再次响应 #  在对端集群的命令执行后, 会响应一个命令复制到当前集群执行\n"},{"id":7,"href":"/zh/docs/user/examples/data-plane-unreachable/","title":"数据面集群不可达","section":"Docs","content":"数据面集群不可达 #  准备至少两个集群才能做演示\n可以是一个节点的集群或者 Kind 起的集群但最少也要两个\n 准备工作 #   准备工作\n初始化控制面集群 #  # 在控制面集群执行 ferryctl control-plane init 加入数据面集群 #  向控制面集群声明哪个数据面集群需要加入 #  # 在控制面集群执行，预连接其他数据平集群 ferryctl control-plane join cluster-1 \u0026#34;--control-plane-tunnel-address=${HOST_IP}:31000\u0026#34; --data-plane-reachable=false --control-plane-tunnel-address 指定对于数据面集群来说控制面集群 Tunnel 的地址 --data-plane-reachable 指定数据面集群是否可达  需要 握手\n完成握手 #  然后可以在控制面集群查看这个数据面集群了\nkubectl get hub.traffic.ferryproxy.io -n ferry-system 快速在本地拉起测试环境 #  如果你没有可以测试集群又想快速尝试可以按照下面的流程\n要求: Docker, Kind, Go\ngit clone https://github.com/ferryproxy/ferry go install ./cmd/ferryctl ./test/hack/start-environment.sh data-plane-unreachable 将会使用 Kind 启动两个集群, 并在控制面集群安装好 ferry-controller, 但是没有配置路由规则\n 环境状况\n在控制面集群配置路由规则\n# 把 cluster-1 的 web-1.test.svc 映射到 control-plane 的 web-1.test.svc # 把 control-plane 的 web-0.test.svc 映射到 cluster-1 的 web-0.test.svc apiVersion: traffic.ferryproxy.io/v1alpha2 kind: RoutePolicy metadata: name: ferry-test namespace: ferry-system spec: exports: - hubName: cluster-1 service: namespace: test name: web-1 - hubName: control-plane service: namespace: test name: web-0 imports: - hubName: cluster-1 - hubName: control-plane # 进入 control-plane 的容器里 去 请求 cluster-1 映射过来的 servuce kubectl --context=kind-ferry-test-control-plane exec -it svc/web-0 -n test -- wget -O - web-1 # 进入 cluster-1 的容器里 去 请求 control-plane 映射过来的 servuce kubectl --context=kind-ferry-test-cluster-1 exec -it svc/web-1 -n test -- wget -O - web-0  示例代码\n"},{"id":8,"href":"/zh/docs/glossary/","title":"术语","section":"Docs","content":"术语 #  API server #  也被称为: kube-apiserver\nAPI服务器是 Kubernetes 控制平面的一个组件，它暴露了 Kubernetes 的 API。API Server 是 Kubernetes 控制平面的前端。\nCluster #  也被称为: 集群\n一个机器，称为节点，运行容器化应用程序。每个集群至少有一个节点。\nController #  也被称为: 控制器\n在 Kubernetes 中，控制器是观察集群状态的控制回路，然后在需要时进行或请求改变。每个控制器都试图使当前的集群状态更接近理想状态。 控制器通过 apiserver（控制平面的一部分）观察集群的共享状态。\nControl Plane #  也被称为: 控制面\n在 Kubernetes 中，中容器协调层，暴露了定义、部署和管理容器生命周期的API和接口。\n该层由许多不同的组件组成，例如（但不限于）。 - Etcd - API Server - Scheduler - Controller Manager\nControl Plane Cluster #  也被称为: 控制面集群\n在多 Kubernetes 集群中，控制平面集群要向其他集群提供控制平面服务。\nData Plane #  也被称为: 数据面\n在 Kubernetes 中，中提供CPU、内存、网络和存储等容量的层，以便容器能够运行并连接到网络。\nData Plane Cluster #  也被称为: 数据面集群\n在多 Kubernetes 集群中, 数据面集群主要工作是自身的服务。\nFerryctl #  一个用于安装和维护 Ferry 的工具。\nFerry-Controller #  它是 Ferry 的控制器，用于推送服务路由规则，并动态地发现需要映射的服务。 需要安装在控制平面集群中\nFerry-Tunnel #  它是 Ferry 的隧道，用于服务从一个集群路由到另一个集群。 需要安装在数据平面集群中\n"},{"id":9,"href":"/zh/docs/user/examples/forward-dial/","title":"转发本地端口到集群的端口","section":"Docs","content":"转发本地端口到集群的端口 #  准备工作 #   准备工作\n转发本地端口到集群的端口 #  ferryctl local forward dial \u0026lt;local address port\u0026gt; \u0026lt;remote service port\u0026gt;  ferryctl local forward dial 0.0.0.0:18080 web-0.test.svc:80 所有对 127.0.0.1:18080 端口的访问都会被转发到 web-0.test.svc:80 端口\n 示例代码\n"},{"id":10,"href":"/zh/docs/user/preparation/","title":"预备工作","section":"Docs","content":"下载 ferryctl #  ferryctl 是 Ferry 的安装运维工具\n需要为每个集群安装 ferryctl\n https://github.com/ferryproxy/ferry/releases\n安装 Tunnel #  需要为每个集群安装 Tunnel\n支持 LoadBalancer 的集群 #  如在各个公有云环境\nferryctl data-plane init --tunnel-service-type=LoadBalancer 其他 #  如 Kind 或私有云环境\n将默认使用 NodePort 暴露 31087 端口\nferryctl data-plane init "},{"id":11,"href":"/zh/docs/user/examples/default/","title":"默认示例","section":"Docs","content":"默认示例 #  准备至少两个集群才能做演示\n可以是一个节点的集群或者 Kind 起的集群但最少也要两个\n 准备工作 #   准备工作\n初始化控制面集群 #  # 在控制面集群执行 ferryctl control-plane init 加入数据面集群 #  向控制面集群声明哪个数据面集群需要加入 #  # 在控制面集群执行，预连接其他数据平集群 ferryctl control-plane join cluster-1 需要 握手\n完成握手 #  然后可以在控制面集群查看这个数据面集群了\nkubectl get hub.traffic.ferryproxy.io -n ferry-system 快速在本地拉起测试环境 #  如果你没有可以测试集群又想快速尝试可以按照下面的流程\n要求: Docker, Kind, Go\ngit clone https://github.com/ferryproxy/ferry go install ./cmd/ferryctl ./test/hack/start-environment.sh default 将会使用 Kind 启动两个集群, 并在控制面集群安装好 ferry-controller, 但是没有配置路由规则\n 环境状况\n在控制面集群配置路由规则\n# 把 cluster-1 的 web-1.test.svc 映射到 control-plane 的 web-1.test.svc # 把 control-plane 的 web-0.test.svc 映射到 cluster-1 的 web-0.test.svc apiVersion: traffic.ferryproxy.io/v1alpha2 kind: RoutePolicy metadata: name: ferry-test namespace: ferry-system spec: exports: - hubName: cluster-1 service: namespace: test name: web-1 - hubName: control-plane service: namespace: test name: web-0 imports: - hubName: cluster-1 - hubName: control-plane # 进入 control-plane 的容器里 请求 cluster-1 映射过来的 servuce kubectl --context=kind-ferry-test-control-plane exec -it svc/web-0 -n test -- wget -O - web-1 # 进入 cluster-1 的容器里 请求 control-plane 映射过来的 servuce kubectl --context=kind-ferry-test-cluster-1 exec -it svc/web-1 -n test -- wget -O - web-0  示例代码\n"}]
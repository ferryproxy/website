[{"id":0,"href":"/docs/roadmap/","title":"Roadmap","section":"Docs","content":"Roadmap #  This document outlines some goals, non-goals, and future aspirations for Ferry as a project.   Engage encryption Use Ferryctl alone to configure service mapping between clusters without the Controller Status is monitored and displayed in the status of the Hub Multi-cluster failover Multi-cluster load balancing IP-based access control Provide an cluster-to-cluster view of traffic flow and service performance Adapting to the ecosystem Support UDP Support mcs api Supports direct UDP p2p connection between two clusters without public IPs  "},{"id":1,"href":"/docs/user/examples/control-plane-unreachable/","title":"Control Plane Unreachable","section":"Docs","content":"Control Plane Unreachable #  Prepare at least two clusters for demonstration\nCan be a cluster of one node or a cluster of Kind but at least two.\n Download ferryctl #  ferryctl is the installation and operation tool for ferry\nA ferryctl needs to be installed for each cluster\u0026rsquo;s control node\n https://github.com/ferryproxy/ferry/releases\nInitialize Control Plane Cluster #  # execute on control plane ferryctl control-plane init --control-plane-reachable=false Join a Data Plane Cluster #  3 steps are required to configure\nDefine which Data Plane Cluster needs to be joined #  # execute on Control Plane Cluster ferryctl control-plane join cluster-1 \u0026#34;--data-plane-tunnel-address=${HOST_IP}:31001\u0026#34; --control-plane-reachable=false --data-plane-tunnel-address Specify the address of the Data Plane Cluster Tunnel for the Control Plane Cluster --control-plane-reachable Specify whether the Data Plane Cluster is reachable  Execute on the Data Plane Cluster #  After the last command is executed of Control Plane Cluster, it responds with a command, copied to Data Plane Cluster to run.\nExecute on the Control Plane Cluster #  After the last command is executed of Data Plane Cluster, it responds with a command, copied to the Control Plane Cluster to run.\nThis data plane cluster can then be viewed in the control plane cluster\nkubectl get hub.traffic.ferryproxy.io -n ferry-system Quickly pull up a test environment locally #  If you don\u0026rsquo;t have a cluster to test and want to try it quickly, you can follow the process below\nRequirement: Docker, Kind, Go\ngit clone https://github.com/ferryproxy/ferry go install ./cmd/ferryctl ./test/hack/start-environment.sh control-plane-unreachable Two clusters will be started using Kind, and the ferry-controller will be installed in the Control Plane Cluster, but no routing rules will be configured\n Environment\nConfiguration route rules\n# Map cluster-1\u0026#39;s web-1.test.svc to control-plane\u0026#39;s web-1.test.svc # Map control-plane\u0026#39;s web-0.test.svc to cluster-1\u0026#39;s web-0.test.svc apiVersion: traffic.ferryproxy.io/v1alpha2 kind: RoutePolicy metadata: name: ferry-test namespace: ferry-system spec: exports: - hubName: cluster-1 service: namespace: test name: web-1 - hubName: control-plane service: namespace: test name: web-0 imports: - hubName: cluster-1 - hubName: control-plane # Go to the control-plane container and request the servuce mapped from cluster-1 kubectl --context=kind-ferry-test-control-plane exec -it svc/web-0 -n test -- wget -O - web-1 # Go to the cluster-1 container and request the servuce mapped from control-plane kubectl --context=kind-ferry-test-cluster-1 exec -it svc/web-1 -n test -- wget -O - web-0  Sample\n"},{"id":2,"href":"/docs/user/examples/data-plane-unreachable/","title":"Data Plane Unreachable","section":"Docs","content":"Data Plane Unreachable #  Prepare at least two clusters for demonstration\nCan be a cluster of one node or a cluster of Kind but at least two.\n Download ferryctl #  ferryctl is the installation and operation tool for ferry\nA ferryctl needs to be installed for each cluster\u0026rsquo;s control node\n https://github.com/ferryproxy/ferry/releases\nInitialize Control Plane Cluster #  # execute on control plane ferryctl control-plane init Join a Data Plane Cluster #  3 steps are required to configure\nDefine which Data Plane Cluster needs to be joined #  # execute on Control Plane Cluster ferryctl control-plane join cluster-1 \u0026#34;--control-plane-tunnel-address=${HOST_IP}:31000\u0026#34; --data-plane-reachable=false --control-plane-tunnel-address Specify the address of the Control Plane Cluster Tunnel for the Data Plane Cluster --data-plane-reachable Specify whether the Data Plane Cluster is reachable  Execute on the Data Plane Cluster #  After the last command is executed of Control Plane Cluster, it responds with a command, copied to Data Plane Cluster to run.\nExecute on the Control Plane Cluster #  After the last command is executed of Data Plane Cluster, it responds with a command, copied to the Control Plane Cluster to run.\nThis data plane cluster can then be viewed in the control plane cluster\nkubectl get hub.traffic.ferryproxy.io -n ferry-system Quickly pull up a test environment locally #  If you don\u0026rsquo;t have a cluster to test and want to try it quickly, you can follow the process below\nRequirement: Docker, Kind, Go\ngit clone https://github.com/ferryproxy/ferry go install ./cmd/ferryctl ./test/hack/start-environment.sh data-plane-unreachable Two clusters will be started using Kind, and the ferry-controller will be installed in the Control Plane Cluster, but no routing rules will be configured\n Environment\nConfiguration route rules\n# Map cluster-1\u0026#39;s web-1.test.svc to control-plane\u0026#39;s web-1.test.svc # Map control-plane\u0026#39;s web-0.test.svc to cluster-1\u0026#39;s web-0.test.svc apiVersion: traffic.ferryproxy.io/v1alpha2 kind: RoutePolicy metadata: name: ferry-test namespace: ferry-system spec: exports: - hubName: cluster-1 service: namespace: test name: web-1 - hubName: control-plane service: namespace: test name: web-0 imports: - hubName: cluster-1 - hubName: control-plane # Go to the control-plane container and request the servuce mapped from cluster-1 kubectl --context=kind-ferry-test-control-plane exec -it svc/web-0 -n test -- wget -O - web-1 # Go to the cluster-1 container and request the servuce mapped from control-plane kubectl --context=kind-ferry-test-cluster-1 exec -it svc/web-1 -n test -- wget -O - web-0  Sample\n"},{"id":3,"href":"/docs/user/examples/default/","title":"Default Example","section":"Docs","content":"Default Example #  Prepare at least two clusters for demonstration\nCan be a cluster of one node or a cluster of Kind but at least two.\n Download ferryctl #  ferryctl is the installation and operation tool for ferry\nA ferryctl needs to be installed for each cluster\u0026rsquo;s control node\n https://github.com/ferryproxy/ferry/releases\nInitialize Control Plane Cluster #  # execute on control plane ferryctl control-plane init Join a Data Plane Cluster #  3 steps are required to configure\nDefine which Data Plane Cluster needs to be joined #  # execute on Control Plane Cluster ferryctl control-plane join cluster-1 Execute on the Data Plane Cluster #  After the last command is executed of Control Plane Cluster, it responds with a command, copied to Data Plane Cluster to run.\nExecute on the Control Plane Cluster #  After the last command is executed of Data Plane Cluster, it responds with a command, copied to the Control Plane Cluster to run.\nThis data plane cluster can then be viewed in the control plane cluster\nkubectl get hub.traffic.ferryproxy.io -n ferry-system Quickly pull up a test environment locally #  If you don\u0026rsquo;t have a cluster to test and want to try it quickly, you can follow the process below\nRequirement: Docker, Kind, Go\ngit clone https://github.com/ferryproxy/ferry go install ./cmd/ferryctl ./test/hack/start-environment.sh default Two clusters will be started using Kind, and the ferry-controller will be installed in the Control Plane Cluster, but no routing rules will be configured\n Environment\nConfiguration route rules\n# Map cluster-1\u0026#39;s web-1.test.svc to control-plane\u0026#39;s web-1.test.svc # Map control-plane\u0026#39;s web-0.test.svc to cluster-1\u0026#39;s web-0.test.svc apiVersion: traffic.ferryproxy.io/v1alpha2 kind: RoutePolicy metadata: name: ferry-test namespace: ferry-system spec: exports: - hubName: cluster-1 service: namespace: test name: web-1 - hubName: control-plane service: namespace: test name: web-0 imports: - hubName: cluster-1 - hubName: control-plane # Go to the control-plane container and request the servuce mapped from cluster-1 kubectl --context=kind-ferry-test-control-plane exec -it svc/web-0 -n test -- wget -O - web-1 # Go to the cluster-1 container and request the servuce mapped from control-plane kubectl --context=kind-ferry-test-cluster-1 exec -it svc/web-1 -n test -- wget -O - web-0  Sample\n"},{"id":4,"href":"/docs/user/examples/forward-dial/","title":"Forward Local Port to Cluster","section":"Docs","content":"Forward Local Port to Cluster #  Installing Tunnel in the cluster #  ferryctl data-plane init Forward Local Port to Cluster #  ferryctl local forward dial \u0026lt;local address port\u0026gt; \u0026lt;remote service port\u0026gt;  ferryctl local forward dial 0.0.0.0:18080 web-0.test.svc:80 All accesses to port 127.0.0.1:18080 are forwarded to port web-0.test.svc:80\n Sample\n"},{"id":5,"href":"/docs/user/examples/forward-listen/","title":"Forward Service to Local Port","section":"Docs","content":"Forward Service to Local Port #  Installing Tunnel in the cluster #  ferryctl data-plane init Forward Service to Local Port #  ferryctl local forward listen \u0026lt;remote service port\u0026gt; \u0026lt;local address port\u0026gt;  ferryctl local forward listen local.test.svc:80 127.0.0.1:28080 All accesses on web-0.test.svc:80 in the cluster are forwarded to the local port 127.0.0.1:28080\n Sample\n"},{"id":6,"href":"/docs/glossary/","title":"Glossary","section":"Docs","content":"Glossary #  API server #  Also known as:kube-apiserver\nThe API server is a component of the Kubernetes control plane that exposes the Kubernetes API. The API server is the front end for the Kubernetes control plane\nCluster #  A set of worker machines, called nodes, that run containerized applications. Every cluster has at least one worker node.\nController #  In Kubernetes, controllers are control loops that watch the state of your cluster, then make or request changes where needed. Each controller tries to move the current cluster state closer to the desired state.\nControllers watch the shared state of your cluster through the apiserver (part of the Control Plane).\nControl Plane #  In Kubernetes, the container orchestration layer that exposes the API and interfaces to define, deploy, and manage the lifecycle of containers.\nThis layer is composed by many different components, such as (but not restricted to): - Etcd - API Server - Scheduler - Controller Manager\nControl Plane Cluster #  In a multi-Kubernetes cluster, the Control Plane Cluster is to provide control plane services to other clusters.\nData Plane #  In Kubernetes, the layer that provides capacity such as CPU, memory, network, and storage so that the containers can run and connect to a network.\nData Plane Cluster #  In a multi-Kubernetes cluster, the Data Plane Cluster works primarily on its own services.\nFerryctl #  A tool for installing and maintaining Ferry\nFerry Controller #  It is the controller of Ferry for pushing Service route rules, and to dynamically discover the Service that needs to be mapped.\nRequires installation in Control Plane Clusters\nFerry Tunnel #  It is the tunnel of Ferry for route the Service from one cluster to another.\nRequires installation in Data Plane Clusters\n"},{"id":7,"href":"/docs/user/examples/manual/","title":"Manual Mapping Service","section":"Docs","content":"Manual Mapping Service #  Why this is needed #  In some cluster unreachability scenarios, the apiserver address of the data plane needs to be exposed to the control plane in advance so that the control plane can access the apiserver of the data plane.\nThe routing rules configured by this feature are not controlled by the ferry-controller.\nInstall Tunnel #  ferryctl data-plane init Manual Mapping Service #  3 steps are required to configure\nDefine exporting a service from another cluster #  ferryctl local manual import --reachable=true \u0026#34;--tunnel-address=${HOST_IP}:31000\u0026#34; --export-host-port=web-1.test.svc:8080 --import-service-name=web-1-8080 This command describes the mapping of the web-1.test.svc:8080 service of the export service cluster to the web-1-8080.ferry-tunnel-system:8080 service of the current cluster\n--reachable=true Is the current cluster is reachable --tunnel-address The address of the Tunnel if the current cluster is reachable --export-host-port Service ports exported from other clusters --import-service-name Mapped services created by the current cluster from services exported from other clusters (by default under the ferry-tunnel-system namespace)  Execute in the cluster of the exported service #  After the previous command is executed, a response is copied to the exported cluster for execution\nExecute in the cluster of the imported service #  After the previous command is executed, a response is copied to the imported cluster for execution\nQuickly pull up a test environment locally #  If you don\u0026rsquo;t have a cluster to test and want to try it quickly, you can follow the process below\nRequirement: Docker, Kind, Go\ngit clone https://github.com/ferryproxy/ferry go install ./cmd/ferryctl ./test/hack/start-environment.sh manual The two clusters will be started using Kind, and the service routing rules between the two clusters will be configured\n Environment\n Sample\n"},{"id":8,"href":"/docs/principle/","title":"Technology Principle","section":"Docs","content":"Technology Principle #  Communication and penetration #  Ferry-Tunnel uses the capabilities of the ssh protocol for communication and penetration between Ferry-Tunnel\nThe following capabilities are primarily used\n  direct-tcpip  tcpip-forward  direct-streamlocal  streamlocal-forward  There are two core points\n Listen to a local port, connect to the Ferry-Tunnel on the other side, and forward all connections through it Connecting to the peer Ferry-Tunnel and listening to a port, and forwarding connections from the listening port to the local  Service Discovery #  Each exported service port will be assigned a port in the Ferry-Tunnel of the imported cluster\nFerry will create a port in the imported cluster for the Headless Service to point to the Ferry-Tunnel\u0026rsquo;s corresponding service in this cluster\n"},{"id":9,"href":"/docs/user/with-service-mesh/","title":"With Service Mesh","section":"Docs","content":"With Service Mesh #  As verified in Istio, Ferry fits perfectly as long as Sidecar is not injected into the ferry-tunnel\n"}]
[{"id":0,"href":"/zh/docs/roadmap/","title":"Roadmap","section":"Docs","content":"路线图 #  本文概述了Ferry作为一个项目的一些目标、非目标和未来的期望。  DONE #   通信加密 只使用 Ferryctl 来配置集群之间的服务映射，而不使用 Controller 支持多级代理 支持 mcs api 负载均衡 监控状态，并显示在Hub的状态中  TODO #   支持完整的卸载自身和清理 适配上下游生态 单个 Hub 支持多副本 Tunnel SSH-via-QUIC: Tunnel 之间的 ssh 协议使用 quic 替换 tcp, 在 IP 变化后无需重新连接, 预期更好的性能 支持任何设备主动连接并加入作为 Hub, 提供 SDK 和 Binary 支持两个无公网 IP 的 Hub 经过控制面撮合, 通过 UDP p2p 直连 故障转移 就近访问  IDEA #   提供流量和业务性能的视图 支持 Service 的 UDP  Suggesting #  如果我们遗漏了一些东西，让 Ferry 对你更有用，请让我们知道。 最好的方法是 提交一个 Issue，并包括关于你打算如何使用 Ferry 的信息。\n"},{"id":1,"href":"/zh/docs/crd/","title":"CRD","section":"Docs","content":"CRD #   Hub 定义一个 Hub, 是与其他 Hub 通信地址\n Route 定义 Hub 之间的单个 Service 的路由规则\n RoutePolicy 是用于定义通用的复合型的路由规则, 最终会转换成 Route\n ServiceImport/ServiceExport 是为了兼容 mcs api, 最终会转换成 RoutePolicy\nTunnelRule 是建立隧道的规则, 还未定义CRD, 使用 ConfigMap 存的\nServicePort 是为导入的隧道建立对应的 Service/Endpoint, 还未定义CRD, 使用 ConfigMap 存的\n"},{"id":2,"href":"/zh/docs/crd/hub/","title":"Hub","section":"CRD","content":"Hub #  Hub CR 定义一个 Hub, 是与其他 Hub 通信地址, 现在只支持一个集群, 未来会添加支持任何可能得设备作为 Hub, 甚至是你的笔记本也行\nHub 为 RoutePolicy CR 和 Route CR 提供了计算的依据\napiVersion: traffic.ferryproxy.io/v1alpha2 kind: Hub spec: gateway: # 表示这个 Hub 是否是可以被连接的 reachable: true # 在 reachable 为 true 时, 其他 Hub 会根据这个地址连接本 Hub address: 1.1.1.1:31087 # 这是一个 Hub 名的列表，本 Hub 需要通过它来到达其他 Hub 使用 # 被 RoutePolicy 用来计算 Route navigationWay: - hubName: hubname # 这是一个 Hub 名的列表，其他 Hub 需要通过它达到本 Hub # 被 RoutePolicy 用来计算 Route receptionWay: - hubName: hubname # 是一个代理的列表，这个 Hub 要到达其他 Hub 必须通过这个代理。 # 当此 Hub 到达其他 Hub 时使用 navigationProxy: - proxy: hubname # 是一个代理的列表，其他 Hub 到达到本 Hub 达必须通过这个代理。 # 当此 Hub 到达其他 Hub 时使用 receptionProxy: - proxy: hubname "},{"id":3,"href":"/zh/docs/crd/mcs_api/","title":"MCS API","section":"CRD","content":"MCS API #  这是在 kubernetes-sigs/mcs-api 定义的一套 API\nFerry 会从所有 Hub CR 被加上 mcs.traffic.ferryproxy.io/service=enabled label 的集群中 获取其 ServiceExport 和 ServiceImport 的 CR, 将其转换为 RoutePolicy CR, 以此兼容 mcs api\n"},{"id":4,"href":"/zh/docs/crd/route/","title":"Route","section":"CRD","content":"Route #  Route CR 定义 Hub 之间的单个 Service 的路由规则\napiVersion: traffic.ferryproxy.io/v1alpha2 kind: Route spec: export: hubName: cluster-1 service: namespace: default name: app-1 import: hubName: cluster-0 service: namespace: default name: app-1 示例的 CR 描述了 Hub cluster-1 导出 Service app-1.default, 在 Hub cluster-0 导入它并命名为 app-1.default 导入和导出的 name 和 namespace 不必一样\n"},{"id":5,"href":"/zh/docs/crd/route_policy/","title":"Route Policy","section":"CRD","content":"Route Policy #  RoutePolicy 是用于定义通用的复合型的路由规则, 最终会转换成 Route CR\n明确路由 #  单对单导入 #  apiVersion: traffic.ferryproxy.io/v1alpha2 kind: RoutePolicy spec: exports: - hubName: cluster-1 service: namespace: default name: app-1 imports: - hubName: cluster-0 service: namespace: default name: app-1 这是一个和 Route CR 的示例等价的 CR\n从多个 Hub 导入 #  apiVersion: traffic.ferryproxy.io/v1alpha2 kind: RoutePolicy spec: exports: - hubName: cluster-1 service: namespace: default name: app-1 - hubName: cluster-2 service: namespace: default name: app-1 imports: - hubName: cluster-0 service: namespace: default name: app-1 这个路由规则会生成两条 Route CR, 分别是把 Hub cluster-2 和 cluster-2 的 app-1.default 导入 Hub cluster-0 这是会在 cluster-0 的 app-1.default 的 endpoint 配置多个 backend 分别指向导入的两条路由\n就算是写在不同的 RoutePolicy CR 或者 Route CR 中, 只要其导入的目的地是一样的都会为 endpoint 配置多个 backend\n导出到多个 Hub #  apiVersion: traffic.ferryproxy.io/v1alpha2 kind: RoutePolicy spec: exports: - hubName: cluster-0 service: namespace: default name: app-1 imports: - hubName: cluster-1 service: namespace: default name: app-1 - hubName: cluster-2 service: namespace: default name: app-1 这条规则其实等价于两条单对单的规则\n匹配的路由 #  除了明确的路由之外, Ferry 提供了 label 筛选需要导入导出 Service 的能力 不过要注意的是匹配路由不能修改导入的 name\n使用 Label 筛选的批量导出 #  apiVersion: traffic.ferryproxy.io/v1alpha2 kind: RoutePolicy spec: exports: - hubName: cluster-1 service: labels: export: enabled namespace: default imports: - hubName: cluster-0 这条路由规则将会在 Hub cluster-1 的 namespace default 中匹配所有带有 export=enabled label 的 Service 导出到 Hub cluster-0\n使用 Label 筛选的批量导入 #  apiVersion: traffic.ferryproxy.io/v1alpha2 kind: RoutePolicy spec: exports: - hubName: cluster-1 service: labels: export: enabled namespace: default imports: - hubName: cluster-0 service: labels: export-2: enabled 这条规则在上一条的基础上增加了导出的 Service 必须还带有 export-2=enabled label\n"},{"id":6,"href":"/zh/docs/user/examples/forward-listen/","title":"创建并转发集群的 Service 端口到本地端口","section":"Docs","content":"创建并转发集群的 Service 端口到本地端口 #  准备工作 #   准备工作\n创建并转发集群的 Service 端口到本地端口 #  ferryctl local forward listen \u0026lt;remote service port\u0026gt; \u0026lt;local address port\u0026gt;  ferryctl local forward listen local.test.svc:80 127.0.0.1:28080 所有在集群里 web-0.test.svc:80 端口的访问都会被转发到本地的 127.0.0.1:28080 端口\n 示例代码\n"},{"id":7,"href":"/zh/docs/user/with-service-mesh/","title":"和服务网格一起使用","section":"Docs","content":"和服务网格一起使用 #  通过在 Istio 中验证, 只要不往 ferry-tunnel 中注入 Sidecar, Ferry 可以完美适配\n"},{"id":8,"href":"/zh/docs/user/examples/manual/","title":"手动映射服务","section":"Docs","content":"手动映射服务 #  为什么需要这个 #  在某些集群不可达的场景里, 需要提前暴露数据面的 apiserver 地址给控制面, 这样控制面就可以访问数据面的 apiserver\n由该功能配置的路由规则不受 ferry-controller 的控制\n准备工作 #   准备工作\n手动映射服务 #  定义从其他集群导出某一服务 #  ferryctl local manual import --reachable=true --tunnel-address=tunneladdress:31000 --export-service=web-1.test --import-service=web-1-8080.ferry-tunnel-system --port=8080 这条命令描述将导出服务集群的 web-1.test.svc:8080 服务映射到当前集群的 web-1-8080.ferry-tunnel-system:8080 服务\n--tunnel-address 当前集群如果可以达到的情况下 Tunnel 的地址 --port 从其他集群导出的服务端口 --export-service 从其他集群导出的服务 --import-service 当前集群从其他集群导出的服务建立的映射服务  需要 握手\n快速在本地拉起测试环境 #  如果你没有可以测试集群又想快速尝试可以按照下面的流程\n要求: Docker, Kind, Go\ngit clone https://github.com/ferryproxy/ferry go install ./cmd/ferryctl ./test/hack/start-environment.sh manual 将会使用 Kind 启动两个集群, 并配置好两个集群之间的服务路由规则\n 环境状况\n 示例代码\n"},{"id":9,"href":"/zh/docs/principle/","title":"技术原理","section":"Docs","content":"技术原理 #  通信和穿透 #  Ferry-Tunnel 之间使用 ssh 协议的能力实现通信和穿透\n主要使用以下能力\n  direct-tcpip  tcpip-forward  direct-streamlocal  streamlocal-forward  核心就两点\n 监听本地一个端口, 连接上对端的 Ferry-Tunnel, 并通过其转发所有连接 连接上对端的 Ferry-Tunnel 并监听一个端口, 转发监听端口的连接到本地  服务发现 #  每一个导出的服务端口都会在导入的集群中的 Ferry-Tunnel 分配一个端口\nFerry 会在导入的集群创建 Headless Service 指向本集群的 Ferry-Tunnel 对应服务的端口\n"},{"id":10,"href":"/zh/docs/user/examples/control-plane-unreachable/","title":"控制面集群不可达","section":"Docs","content":"控制面集群不可达 #  准备至少两个集群才能做演示\n可以是一个节点的集群或者 Kind 起的集群但最少也要两个\n 准备工作 #   准备工作\n初始化控制面集群 #  # 在控制面集群执行 ferryctl control-plane init --control-plane-reachable=false --control-plane-reachable 指定控制面集群是否可达  加入数据面集群 #  向控制面集群声明哪个数据面集群需要加入 #  # 在控制面集群执行，预连接其他数据平集群 ferryctl control-plane join cluster-1 \u0026#34;--data-plane-tunnel-address=${HOST_IP}:31001\u0026#34; --control-plane-reachable=false --data-plane-tunnel-address 指定对于控制面集群来说数据面集群 Tunnel 的地址 --control-plane-reachable 指定控制面集群是否可达  需要 握手\n完成握手 #  然后可以在控制面集群查看这个数据面集群了\nkubectl get hub.traffic.ferryproxy.io -n ferry-system 快速在本地拉起测试环境 #  如果你没有可以测试集群又想快速尝试可以按照下面的流程\n要求: Docker, Kind, Go\ngit clone https://github.com/ferryproxy/ferry go install ./cmd/ferryctl ./test/hack/start-environment.sh control-plane-unreachable 将会使用 Kind 启动两个集群, 并在控制面集群安装好 ferry-controller, 但是没有配置路由规则\n 环境状况\n在控制面集群配置路由规则\n# 把 cluster-1 的 web-1.test.svc 映射到 control-plane 的 web-1.test.svc # 把 control-plane 的 web-0.test.svc 映射到 cluster-1 的 web-0.test.svc apiVersion: traffic.ferryproxy.io/v1alpha2 kind: RoutePolicy metadata: name: ferry-test namespace: ferry-system spec: exports: - hubName: cluster-1 service: namespace: test name: web-1 - hubName: control-plane service: namespace: test name: web-0 imports: - hubName: cluster-1 - hubName: control-plane # 进入 control-plane 的容器里 去 请求 cluster-1 映射过来的 servuce kubectl --context=kind-ferry-test-control-plane exec -it svc/web-0 -n test -- wget -O - web-1 # 进入 cluster-1 的容器里 去 请求 control-plane 映射过来的 servuce kubectl --context=kind-ferry-test-cluster-1 exec -it svc/web-1 -n test -- wget -O - web-0  示例代码\n"},{"id":11,"href":"/zh/docs/user/handshake/","title":"握手","section":"Docs","content":"握手 #  部分命令需要通知两个集群这个行为称之为握手\n自动 #  如果能同时连上两个集群\nKUBECONFIG 指定当前集群的 kubeconfig 文件\nFERRY_PEER_KUBECONFIG 指定对端集群的 kubeconfig 文件\n手动 #  如果不能同时连上两个集群\n首次响应 #  在当前集群的命令执行后, 会响应一个命令复制到对端集群执行\n再次响应 #  在对端集群的命令执行后, 会响应一个命令复制到当前集群执行\n"},{"id":12,"href":"/zh/docs/user/examples/data-plane-unreachable/","title":"数据面集群不可达","section":"Docs","content":"数据面集群不可达 #  准备至少两个集群才能做演示\n可以是一个节点的集群或者 Kind 起的集群但最少也要两个\n 准备工作 #   准备工作\n初始化控制面集群 #  # 在控制面集群执行 ferryctl control-plane init 加入数据面集群 #  向控制面集群声明哪个数据面集群需要加入 #  # 在控制面集群执行，预连接其他数据平集群 ferryctl control-plane join cluster-1 \u0026#34;--control-plane-tunnel-address=${HOST_IP}:31000\u0026#34; --data-plane-reachable=false --control-plane-tunnel-address 指定对于数据面集群来说控制面集群 Tunnel 的地址 --data-plane-reachable 指定数据面集群是否可达  需要 握手\n完成握手 #  然后可以在控制面集群查看这个数据面集群了\nkubectl get hub.traffic.ferryproxy.io -n ferry-system 快速在本地拉起测试环境 #  如果你没有可以测试集群又想快速尝试可以按照下面的流程\n要求: Docker, Kind, Go\ngit clone https://github.com/ferryproxy/ferry go install ./cmd/ferryctl ./test/hack/start-environment.sh data-plane-unreachable 将会使用 Kind 启动两个集群, 并在控制面集群安装好 ferry-controller, 但是没有配置路由规则\n 环境状况\n在控制面集群配置路由规则\n# 把 cluster-1 的 web-1.test.svc 映射到 control-plane 的 web-1.test.svc # 把 control-plane 的 web-0.test.svc 映射到 cluster-1 的 web-0.test.svc apiVersion: traffic.ferryproxy.io/v1alpha2 kind: RoutePolicy metadata: name: ferry-test namespace: ferry-system spec: exports: - hubName: cluster-1 service: namespace: test name: web-1 - hubName: control-plane service: namespace: test name: web-0 imports: - hubName: cluster-1 - hubName: control-plane # 进入 control-plane 的容器里 去 请求 cluster-1 映射过来的 servuce kubectl --context=kind-ferry-test-control-plane exec -it svc/web-0 -n test -- wget -O - web-1 # 进入 cluster-1 的容器里 去 请求 control-plane 映射过来的 servuce kubectl --context=kind-ferry-test-cluster-1 exec -it svc/web-1 -n test -- wget -O - web-0  示例代码\n"},{"id":13,"href":"/zh/docs/glossary/","title":"术语","section":"Docs","content":"术语 #  API server #  也被称为: kube-apiserver\nAPI服务器是 Kubernetes 控制平面的一个组件，它暴露了 Kubernetes 的 API。API Server 是 Kubernetes 控制平面的前端。\nCluster #  也被称为: 集群\n一个机器，称为节点，运行容器化应用程序。每个集群至少有一个节点。\nController #  也被称为: 控制器\n在 Kubernetes 中，控制器是观察集群状态的控制回路，然后在需要时进行或请求改变。每个控制器都试图使当前的集群状态更接近理想状态。 控制器通过 apiserver（控制平面的一部分）观察集群的共享状态。\nControl Plane #  也被称为: 控制面\n在 Kubernetes 中，中容器协调层，暴露了定义、部署和管理容器生命周期的API和接口。\n该层由许多不同的组件组成，例如（但不限于）。 - Etcd - API Server - Scheduler - Controller Manager\nControl Plane Cluster #  也被称为: 控制面集群\n在多 Kubernetes 集群中，控制平面集群要向其他集群提供控制平面服务。\nData Plane #  也被称为: 数据面\n在 Kubernetes 中，中提供CPU、内存、网络和存储等容量的层，以便容器能够运行并连接到网络。\nData Plane Cluster #  也被称为: 数据面集群\n在多 Kubernetes 集群中, 数据面集群主要工作是自身的服务。\nFerryctl #  一个用于安装和维护 Ferry 的工具。\nFerry-Controller #  它是 Ferry 的控制器，用于推送服务路由规则，并动态地发现需要映射的服务。 需要安装在控制平面集群中\nFerry-Tunnel #  它是 Ferry 的隧道，用于服务从一个集群路由到另一个集群。 需要安装在数据平面集群中\n"},{"id":14,"href":"/zh/docs/user/examples/forward-dial/","title":"转发本地端口到集群的端口","section":"Docs","content":"转发本地端口到集群的端口 #  准备工作 #   准备工作\n转发本地端口到集群的端口 #  ferryctl local forward dial \u0026lt;local address port\u0026gt; \u0026lt;remote service port\u0026gt;  ferryctl local forward dial 0.0.0.0:18080 web-0.test.svc:80 所有对 127.0.0.1:18080 端口的访问都会被转发到 web-0.test.svc:80 端口\n 示例代码\n"},{"id":15,"href":"/zh/docs/user/preparation/","title":"预备工作","section":"Docs","content":"下载 ferryctl #  ferryctl 是 Ferry 的安装运维工具\n需要为每个集群安装 ferryctl\n https://github.com/ferryproxy/ferry/releases\n安装 Tunnel #  需要为每个集群安装 Tunnel\n支持 LoadBalancer 的集群 #  如在各个公有云环境\nferryctl data-plane init --tunnel-service-type=LoadBalancer 其他 #  如 Kind 或私有云环境\n将默认使用 NodePort 暴露 31087 端口\nferryctl data-plane init "},{"id":16,"href":"/zh/docs/user/examples/default/","title":"默认示例","section":"Docs","content":"默认示例 #  准备至少两个集群才能做演示\n可以是一个节点的集群或者 Kind 起的集群但最少也要两个\n 准备工作 #   准备工作\n初始化控制面集群 #  # 在控制面集群执行 ferryctl control-plane init 加入数据面集群 #  向控制面集群声明哪个数据面集群需要加入 #  # 在控制面集群执行，预连接其他数据平集群 ferryctl control-plane join cluster-1 需要 握手\n完成握手 #  然后可以在控制面集群查看这个数据面集群了\nkubectl get hub.traffic.ferryproxy.io -n ferry-system 快速在本地拉起测试环境 #  如果你没有可以测试集群又想快速尝试可以按照下面的流程\n要求: Docker, Kind, Go\ngit clone https://github.com/ferryproxy/ferry go install ./cmd/ferryctl ./test/hack/start-environment.sh default 将会使用 Kind 启动两个集群, 并在控制面集群安装好 ferry-controller, 但是没有配置路由规则\n 环境状况\n在控制面集群配置路由规则\n# 把 cluster-1 的 web-1.test.svc 映射到 control-plane 的 web-1.test.svc # 把 control-plane 的 web-0.test.svc 映射到 cluster-1 的 web-0.test.svc apiVersion: traffic.ferryproxy.io/v1alpha2 kind: RoutePolicy metadata: name: ferry-test namespace: ferry-system spec: exports: - hubName: cluster-1 service: namespace: test name: web-1 - hubName: control-plane service: namespace: test name: web-0 imports: - hubName: cluster-1 - hubName: control-plane # 进入 control-plane 的容器里 请求 cluster-1 映射过来的 servuce kubectl --context=kind-ferry-test-control-plane exec -it svc/web-0 -n test -- wget -O - web-1 # 进入 cluster-1 的容器里 请求 control-plane 映射过来的 servuce kubectl --context=kind-ferry-test-cluster-1 exec -it svc/web-1 -n test -- wget -O - web-0  示例代码\n"}]
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Docs on Ferry Proxy</title><link>https://ferryproxy.io/zh/docs/</link><description>Recent content in Docs on Ferry Proxy</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://ferryproxy.io/zh/docs/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://ferryproxy.io/zh/docs/roadmap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ferryproxy.io/zh/docs/roadmap/</guid><description>路线图 # 本文概述了Ferry作为一个项目的一些目标、非目标和未来的期望。 DONE # 通信加密 只使用 Ferryctl 来配置集群之间的服务映射，而不使用 Controller 支持多级代理 TODO # 支持完整的卸载自身和清理 监控状态，并显示在Hub的状态中 适配上下游生态 支持 mcs api 单个 Hub 支持多副本 Tunnel SSH-via-QUIC: Tunnel 之间的 ssh 协议使用 quic 替换 tcp, 在 IP 变化后无需重新连接, 预期更好的性能 支持任何设备主动连接并加入作为 Hub, 提供 SDK 和 Binary 支持两个无公网 IP 的 Hub 经过控制面撮合, 通过 UDP p2p 直连 负载均衡 故障转移 就近访问 访问控制 IDEA # 提供流量和业务性能的视图 支持 Service 的 UDP Suggesting # 如果我们遗漏了一些东西，让 Ferry 对你更有用，请让我们知道。 最好的方法是 提交一个 Issue，并包括关于你打算如何使用 Ferry 的信息。</description></item><item><title>创建并转发集群的 Service 端口到本地端口</title><link>https://ferryproxy.io/zh/docs/user/examples/forward-listen/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ferryproxy.io/zh/docs/user/examples/forward-listen/</guid><description>创建并转发集群的 Service 端口到本地端口 # 准备工作 # 准备工作
创建并转发集群的 Service 端口到本地端口 # ferryctl local forward listen &amp;lt;remote service port&amp;gt; &amp;lt;local address port&amp;gt; ferryctl local forward listen local.test.svc:80 127.0.0.1:28080 所有在集群里 web-0.test.svc:80 端口的访问都会被转发到本地的 127.0.0.1:28080 端口
示例代码</description></item><item><title>和服务网格一起使用</title><link>https://ferryproxy.io/zh/docs/user/with-service-mesh/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ferryproxy.io/zh/docs/user/with-service-mesh/</guid><description>和服务网格一起使用 # 通过在 Istio 中验证, 只要不往 ferry-tunnel 中注入 Sidecar, Ferry 可以完美适配</description></item><item><title>手动映射服务</title><link>https://ferryproxy.io/zh/docs/user/examples/manual/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ferryproxy.io/zh/docs/user/examples/manual/</guid><description>手动映射服务 # 为什么需要这个 # 在某些集群不可达的场景里, 需要提前暴露数据面的 apiserver 地址给控制面, 这样控制面就可以访问数据面的 apiserver
由该功能配置的路由规则不受 ferry-controller 的控制
准备工作 # 准备工作
手动映射服务 # 定义从其他集群导出某一服务 # ferryctl local manual import --reachable=true &amp;#34;--tunnel-address=${HOST_IP}:31000&amp;#34; --export-host-port=web-1.test.svc:8080 --import-service-name=web-1-8080 这条命令描述将导出服务集群的 web-1.test.svc:8080 服务映射到当前集群的 web-1-8080.ferry-tunnel-system:8080 服务
--reachable=true 当前集群是否可以达到 --tunnel-address 当前集群如果可以达到的情况下 Tunnel 的地址 --export-host-port 从其他集群导出的服务端口 --import-service-name 当前集群从其他集群导出的服务建立的映射服务 (默认在 ferry-tunnel-system 命名空间下) 需要 握手
快速在本地拉起测试环境 # 如果你没有可以测试集群又想快速尝试可以按照下面的流程
要求: Docker, Kind, Go
git clone https://github.com/ferryproxy/ferry go install ./cmd/ferryctl ./test/hack/start-environment.sh manual 将会使用 Kind 启动两个集群, 并配置好两个集群之间的服务路由规则</description></item><item><title>技术原理</title><link>https://ferryproxy.io/zh/docs/principle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ferryproxy.io/zh/docs/principle/</guid><description>技术原理 # 通信和穿透 # Ferry-Tunnel 之间使用 ssh 协议的能力实现通信和穿透
主要使用以下能力
direct-tcpip tcpip-forward direct-streamlocal streamlocal-forward 核心就两点
监听本地一个端口, 连接上对端的 Ferry-Tunnel, 并通过其转发所有连接 连接上对端的 Ferry-Tunnel 并监听一个端口, 转发监听端口的连接到本地 服务发现 # 每一个导出的服务端口都会在导入的集群中的 Ferry-Tunnel 分配一个端口
Ferry 会在导入的集群创建 Headless Service 指向本集群的 Ferry-Tunnel 对应服务的端口</description></item><item><title>控制面集群不可达</title><link>https://ferryproxy.io/zh/docs/user/examples/control-plane-unreachable/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ferryproxy.io/zh/docs/user/examples/control-plane-unreachable/</guid><description>控制面集群不可达 # 准备至少两个集群才能做演示
可以是一个节点的集群或者 Kind 起的集群但最少也要两个
准备工作 # 准备工作
初始化控制面集群 # # 在控制面集群执行 ferryctl control-plane init --control-plane-reachable=false --control-plane-reachable 指定控制面集群是否可达 加入数据面集群 # 向控制面集群声明哪个数据面集群需要加入 # # 在控制面集群执行，预连接其他数据平集群 ferryctl control-plane join cluster-1 &amp;#34;--data-plane-tunnel-address=${HOST_IP}:31001&amp;#34; --control-plane-reachable=false --data-plane-tunnel-address 指定对于控制面集群来说数据面集群 Tunnel 的地址 --control-plane-reachable 指定控制面集群是否可达 需要 握手
完成握手 # 然后可以在控制面集群查看这个数据面集群了
kubectl get hub.traffic.ferryproxy.io -n ferry-system 快速在本地拉起测试环境 # 如果你没有可以测试集群又想快速尝试可以按照下面的流程
要求: Docker, Kind, Go
git clone https://github.com/ferryproxy/ferry go install .</description></item><item><title>握手</title><link>https://ferryproxy.io/zh/docs/user/handshake/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ferryproxy.io/zh/docs/user/handshake/</guid><description>握手 # 部分命令需要通知两个集群这个行为称之为握手
自动 # 如果能同时连上两个集群
KUBECONFIG 指定当前集群的 kubeconfig 文件
FERRY_PEER_KUBECONFIG 指定对端集群的 kubeconfig 文件
手动 # 如果不能同时连上两个集群
首次响应 # 在当前集群的命令执行后, 会响应一个命令复制到对端集群执行
再次响应 # 在对端集群的命令执行后, 会响应一个命令复制到当前集群执行</description></item><item><title>数据面集群不可达</title><link>https://ferryproxy.io/zh/docs/user/examples/data-plane-unreachable/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ferryproxy.io/zh/docs/user/examples/data-plane-unreachable/</guid><description>数据面集群不可达 # 准备至少两个集群才能做演示
可以是一个节点的集群或者 Kind 起的集群但最少也要两个
准备工作 # 准备工作
初始化控制面集群 # # 在控制面集群执行 ferryctl control-plane init 加入数据面集群 # 向控制面集群声明哪个数据面集群需要加入 # # 在控制面集群执行，预连接其他数据平集群 ferryctl control-plane join cluster-1 &amp;#34;--control-plane-tunnel-address=${HOST_IP}:31000&amp;#34; --data-plane-reachable=false --control-plane-tunnel-address 指定对于数据面集群来说控制面集群 Tunnel 的地址 --data-plane-reachable 指定数据面集群是否可达 需要 握手
完成握手 # 然后可以在控制面集群查看这个数据面集群了
kubectl get hub.traffic.ferryproxy.io -n ferry-system 快速在本地拉起测试环境 # 如果你没有可以测试集群又想快速尝试可以按照下面的流程
要求: Docker, Kind, Go
git clone https://github.com/ferryproxy/ferry go install ./cmd/ferryctl ./test/hack/start-environment.sh data-plane-unreachable 将会使用 Kind 启动两个集群, 并在控制面集群安装好 ferry-controller, 但是没有配置路由规则</description></item><item><title>术语</title><link>https://ferryproxy.io/zh/docs/glossary/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ferryproxy.io/zh/docs/glossary/</guid><description>术语 # API server # 也被称为: kube-apiserver
API服务器是 Kubernetes 控制平面的一个组件，它暴露了 Kubernetes 的 API。API Server 是 Kubernetes 控制平面的前端。
Cluster # 也被称为: 集群
一个机器，称为节点，运行容器化应用程序。每个集群至少有一个节点。
Controller # 也被称为: 控制器
在 Kubernetes 中，控制器是观察集群状态的控制回路，然后在需要时进行或请求改变。每个控制器都试图使当前的集群状态更接近理想状态。 控制器通过 apiserver（控制平面的一部分）观察集群的共享状态。
Control Plane # 也被称为: 控制面
在 Kubernetes 中，中容器协调层，暴露了定义、部署和管理容器生命周期的API和接口。
该层由许多不同的组件组成，例如（但不限于）。 - Etcd - API Server - Scheduler - Controller Manager
Control Plane Cluster # 也被称为: 控制面集群
在多 Kubernetes 集群中，控制平面集群要向其他集群提供控制平面服务。
Data Plane # 也被称为: 数据面</description></item><item><title>转发本地端口到集群的端口</title><link>https://ferryproxy.io/zh/docs/user/examples/forward-dial/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ferryproxy.io/zh/docs/user/examples/forward-dial/</guid><description>转发本地端口到集群的端口 # 准备工作 # 准备工作
转发本地端口到集群的端口 # ferryctl local forward dial &amp;lt;local address port&amp;gt; &amp;lt;remote service port&amp;gt; ferryctl local forward dial 0.0.0.0:18080 web-0.test.svc:80 所有对 127.0.0.1:18080 端口的访问都会被转发到 web-0.test.svc:80 端口
示例代码</description></item><item><title>预备工作</title><link>https://ferryproxy.io/zh/docs/user/preparation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ferryproxy.io/zh/docs/user/preparation/</guid><description>下载 ferryctl # ferryctl 是 Ferry 的安装运维工具
需要为每个集群安装 ferryctl
https://github.com/ferryproxy/ferry/releases
安装 Tunnel # 需要为每个集群安装 Tunnel
支持 LoadBalancer 的集群 # 如在各个公有云环境
ferryctl data-plane init --tunnel-service-type=LoadBalancer 其他 # 如 Kind 或私有云环境
将默认使用 NodePort 暴露 31087 端口
ferryctl data-plane init</description></item><item><title>默认示例</title><link>https://ferryproxy.io/zh/docs/user/examples/default/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ferryproxy.io/zh/docs/user/examples/default/</guid><description>默认示例 # 准备至少两个集群才能做演示
可以是一个节点的集群或者 Kind 起的集群但最少也要两个
准备工作 # 准备工作
初始化控制面集群 # # 在控制面集群执行 ferryctl control-plane init 加入数据面集群 # 向控制面集群声明哪个数据面集群需要加入 # # 在控制面集群执行，预连接其他数据平集群 ferryctl control-plane join cluster-1 需要 握手
完成握手 # 然后可以在控制面集群查看这个数据面集群了
kubectl get hub.traffic.ferryproxy.io -n ferry-system 快速在本地拉起测试环境 # 如果你没有可以测试集群又想快速尝试可以按照下面的流程
要求: Docker, Kind, Go
git clone https://github.com/ferryproxy/ferry go install ./cmd/ferryctl ./test/hack/start-environment.sh default 将会使用 Kind 启动两个集群, 并在控制面集群安装好 ferry-controller, 但是没有配置路由规则
环境状况
在控制面集群配置路由规则
# 把 cluster-1 的 web-1.</description></item></channel></rss>
[{"id":0,"href":"/docs/roadmap/","title":"Roadmap","section":"Docs","content":"Roadmap #  This document outlines some goals, non-goals, and future aspirations for Ferry as a project.  DONE #   Engage encryption Use Ferryctl alone to configure service mapping between clusters without the Controller Support multi-level proxy  TODO #   Support complete uninstallation itself and cleanup Status is monitored and displayed in the status of the Hub Adapting to the ecosystem SSH-via-QUIC: QUIC is used to replace TCP in SSH, no need to reconnect after an IP change, expect better performance Support mcs api Support any server with sshd as a hub without Cluster  IDEA #   Multi-cluster failover Multi-cluster load balancing IP-based access control Provide an cluster-to-cluster view of traffic flow and service performance Support UDP of Service Supports direct UDP p2p connection between two clusters without public IPs  Suggesting #  If we\u0026rsquo;ve missed something that would make Ferry more useful to you, please let us know. The best way to do this is to Submit an Issue and include information about how you plan to use Ferry.\n"},{"id":1,"href":"/docs/user/examples/control-plane-unreachable/","title":"Control Plane Unreachable","section":"Docs","content":"Control Plane Unreachable #  Prepare at least two clusters for demonstration\nCan be a cluster of one node or a cluster of Kind but at least two.\n Preparation #   Preparation\nInitialize Control Plane Cluster #  # execute on control plane ferryctl control-plane init --control-plane-reachable=false Join a Data Plane Cluster #  Define which Data Plane Cluster needs to be joined #  # execute on Control Plane Cluster ferryctl control-plane join cluster-1 \u0026#34;--data-plane-tunnel-address=${HOST_IP}:31001\u0026#34; --control-plane-reachable=false --data-plane-tunnel-address Specify the address of the Data Plane Cluster Tunnel for the Control Plane Cluster --control-plane-reachable Specify whether the Data Plane Cluster is reachable  Need handshake\nComplete handshake #  This data plane cluster can then be viewed in the control plane cluster\nkubectl get hub.traffic.ferryproxy.io -n ferry-system Quickly pull up a test environment locally #  If you don\u0026rsquo;t have a cluster to test and want to try it quickly, you can follow the process below\nRequirement: Docker, Kind, Go\ngit clone https://github.com/ferryproxy/ferry go install ./cmd/ferryctl ./test/hack/start-environment.sh control-plane-unreachable Two clusters will be started using Kind, and the ferry-controller will be installed in the Control Plane Cluster, but no routing rules will be configured\n Environment\nConfiguration route rules\n# Map cluster-1\u0026#39;s web-1.test.svc to control-plane\u0026#39;s web-1.test.svc # Map control-plane\u0026#39;s web-0.test.svc to cluster-1\u0026#39;s web-0.test.svc apiVersion: traffic.ferryproxy.io/v1alpha2 kind: RoutePolicy metadata: name: ferry-test namespace: ferry-system spec: exports: - hubName: cluster-1 service: namespace: test name: web-1 - hubName: control-plane service: namespace: test name: web-0 imports: - hubName: cluster-1 - hubName: control-plane # Go to the control-plane container and request the servuce mapped from cluster-1 kubectl --context=kind-ferry-test-control-plane exec -it svc/web-0 -n test -- wget -O - web-1 # Go to the cluster-1 container and request the servuce mapped from control-plane kubectl --context=kind-ferry-test-cluster-1 exec -it svc/web-1 -n test -- wget -O - web-0  Sample\n"},{"id":2,"href":"/docs/user/examples/data-plane-unreachable/","title":"Data Plane Unreachable","section":"Docs","content":"Data Plane Unreachable #  Prepare at least two clusters for demonstration\nCan be a cluster of one node or a cluster of Kind but at least two.\n Preparation #   Preparation\nInitialize Control Plane Cluster #  # execute on control plane ferryctl control-plane init Join a Data Plane Cluster #  Define which Data Plane Cluster needs to be joined #  # execute on Control Plane Cluster ferryctl control-plane join cluster-1 \u0026#34;--control-plane-tunnel-address=${HOST_IP}:31000\u0026#34; --data-plane-reachable=false --control-plane-tunnel-address Specify the address of the Control Plane Cluster Tunnel for the Data Plane Cluster --data-plane-reachable Specify whether the Data Plane Cluster is reachable  Need handshake\nComplete handshake #  This data plane cluster can then be viewed in the control plane cluster\nkubectl get hub.traffic.ferryproxy.io -n ferry-system Quickly pull up a test environment locally #  If you don\u0026rsquo;t have a cluster to test and want to try it quickly, you can follow the process below\nRequirement: Docker, Kind, Go\ngit clone https://github.com/ferryproxy/ferry go install ./cmd/ferryctl ./test/hack/start-environment.sh data-plane-unreachable Two clusters will be started using Kind, and the ferry-controller will be installed in the Control Plane Cluster, but no routing rules will be configured\n Environment\nConfiguration route rules\n# Map cluster-1\u0026#39;s web-1.test.svc to control-plane\u0026#39;s web-1.test.svc # Map control-plane\u0026#39;s web-0.test.svc to cluster-1\u0026#39;s web-0.test.svc apiVersion: traffic.ferryproxy.io/v1alpha2 kind: RoutePolicy metadata: name: ferry-test namespace: ferry-system spec: exports: - hubName: cluster-1 service: namespace: test name: web-1 - hubName: control-plane service: namespace: test name: web-0 imports: - hubName: cluster-1 - hubName: control-plane # Go to the control-plane container and request the servuce mapped from cluster-1 kubectl --context=kind-ferry-test-control-plane exec -it svc/web-0 -n test -- wget -O - web-1 # Go to the cluster-1 container and request the servuce mapped from control-plane kubectl --context=kind-ferry-test-cluster-1 exec -it svc/web-1 -n test -- wget -O - web-0  Sample\n"},{"id":3,"href":"/docs/user/examples/default/","title":"Default Example","section":"Docs","content":"Default Example #  Prepare at least two clusters for demonstration\nCan be a cluster of one node or a cluster of Kind but at least two.\n Download ferryctl #  ferryctl is the installation and operation tool for ferry\nA ferryctl needs to be installed for each cluster\u0026rsquo;s control node\n https://github.com/ferryproxy/ferry/releases\nPreparation #   Preparation\nJoin a Data Plane Cluster #  Define which Data Plane Cluster needs to be joined #  # execute on Control Plane Cluster ferryctl control-plane join cluster-1 Need handshake\nComplete handshake #  This data plane cluster can then be viewed in the control plane cluster\nkubectl get hub.traffic.ferryproxy.io -n ferry-system Quickly pull up a test environment locally #  If you don\u0026rsquo;t have a cluster to test and want to try it quickly, you can follow the process below\nRequirement: Docker, Kind, Go\ngit clone https://github.com/ferryproxy/ferry go install ./cmd/ferryctl ./test/hack/start-environment.sh default Two clusters will be started using Kind, and the ferry-controller will be installed in the Control Plane Cluster, but no routing rules will be configured\n Environment\nConfiguration route rules\n# Map cluster-1\u0026#39;s web-1.test.svc to control-plane\u0026#39;s web-1.test.svc # Map control-plane\u0026#39;s web-0.test.svc to cluster-1\u0026#39;s web-0.test.svc apiVersion: traffic.ferryproxy.io/v1alpha2 kind: RoutePolicy metadata: name: ferry-test namespace: ferry-system spec: exports: - hubName: cluster-1 service: namespace: test name: web-1 - hubName: control-plane service: namespace: test name: web-0 imports: - hubName: cluster-1 - hubName: control-plane # Go to the control-plane container and request the servuce mapped from cluster-1 kubectl --context=kind-ferry-test-control-plane exec -it svc/web-0 -n test -- wget -O - web-1 # Go to the cluster-1 container and request the servuce mapped from control-plane kubectl --context=kind-ferry-test-cluster-1 exec -it svc/web-1 -n test -- wget -O - web-0  Sample\n"},{"id":4,"href":"/docs/user/examples/forward-dial/","title":"Forward Local Port to Cluster","section":"Docs","content":"Forward Local Port to Cluster #  Preparation #   Preparation\nForward Local Port to Cluster #  ferryctl local forward dial \u0026lt;local address port\u0026gt; \u0026lt;remote service port\u0026gt;  ferryctl local forward dial 0.0.0.0:18080 web-0.test.svc:80 All accesses to port 127.0.0.1:18080 are forwarded to port web-0.test.svc:80\n Sample\n"},{"id":5,"href":"/docs/user/examples/forward-listen/","title":"Forward Service to Local Port","section":"Docs","content":"Forward Service to Local Port #  Preparation #   Preparation\nForward Service to Local Port #  ferryctl local forward listen \u0026lt;remote service port\u0026gt; \u0026lt;local address port\u0026gt;  ferryctl local forward listen local.test.svc:80 127.0.0.1:28080 All accesses on web-0.test.svc:80 in the cluster are forwarded to the local port 127.0.0.1:28080\n Sample\n"},{"id":6,"href":"/docs/glossary/","title":"Glossary","section":"Docs","content":"Glossary #  API server #  Also known as:kube-apiserver\nThe API server is a component of the Kubernetes control plane that exposes the Kubernetes API. The API server is the front end for the Kubernetes control plane\nCluster #  A set of worker machines, called nodes, that run containerized applications. Every cluster has at least one worker node.\nController #  In Kubernetes, controllers are control loops that watch the state of your cluster, then make or request changes where needed. Each controller tries to move the current cluster state closer to the desired state.\nControllers watch the shared state of your cluster through the apiserver (part of the Control Plane).\nControl Plane #  In Kubernetes, the container orchestration layer that exposes the API and interfaces to define, deploy, and manage the lifecycle of containers.\nThis layer is composed by many different components, such as (but not restricted to): - Etcd - API Server - Scheduler - Controller Manager\nControl Plane Cluster #  In a multi-Kubernetes cluster, the Control Plane Cluster is to provide control plane services to other clusters.\nData Plane #  In Kubernetes, the layer that provides capacity such as CPU, memory, network, and storage so that the containers can run and connect to a network.\nData Plane Cluster #  In a multi-Kubernetes cluster, the Data Plane Cluster works primarily on its own services.\nFerryctl #  A tool for installing and maintaining Ferry\nFerry Controller #  It is the controller of Ferry for pushing Service route rules, and to dynamically discover the Service that needs to be mapped.\nRequires installation in Control Plane Clusters\nFerry Tunnel #  It is the tunnel of Ferry for route the Service from one cluster to another.\nRequires installation in Data Plane Clusters\n"},{"id":7,"href":"/docs/user/handshake/","title":"Handshake","section":"Docs","content":"handshake #  Some commands need to notify both clusters of this behavior called handshaking\nAutomatic #  If two clusters can be connected at the same time\nKUBECONFIG specifies the kubeconfig file for the current cluster\nFERRY_PEER_KUBECONFIG specifies the kubeconfig file of the peer cluster\nManual #  If you cannot connect to both clusters at the same time\nFirst response #  After the command is executed in the current cluster, a response is copied to the peer cluster to execution\nSecond response #  After the command is executed in the peer cluster, a command is copied to the current cluster to execution\n"},{"id":8,"href":"/docs/user/examples/manual/","title":"Manual Mapping Service","section":"Docs","content":"Manual Mapping Service #  Why this is needed #  In some cluster unreachability scenarios, the apiserver address of the data plane needs to be exposed to the control plane in advance so that the control plane can access the apiserver of the data plane.\nThe routing rules configured by this feature are not controlled by the ferry-controller.\nPreparation #   Preparation\nManual Mapping Service #  Define exporting a service from another cluster #  ferryctl local manual import --reachable=true \u0026#34;--tunnel-address=${HOST_IP}:31000\u0026#34; --export-host-port=web-1.test.svc:8080 --import-service-name=web-1-8080 This command describes the mapping of the web-1.test.svc:8080 service of the export service cluster to the web-1-8080.ferry-tunnel-system:8080 service of the current cluster\n--reachable=true Is the current cluster is reachable --tunnel-address The address of the Tunnel if the current cluster is reachable --export-host-port Service ports exported from other clusters --import-service-name Mapped services created by the current cluster from services exported from other clusters (by default under the ferry-tunnel-system namespace)  Need handshake\nQuickly pull up a test environment locally #  If you don\u0026rsquo;t have a cluster to test and want to try it quickly, you can follow the process below\nRequirement: Docker, Kind, Go\ngit clone https://github.com/ferryproxy/ferry go install ./cmd/ferryctl ./test/hack/start-environment.sh manual The two clusters will be started using Kind, and the service routing rules between the two clusters will be configured\n Environment\n Sample\n"},{"id":9,"href":"/docs/user/preparation/","title":"Preparation","section":"Docs","content":"Download ferryctl #  ferryctl is the installation and maintenance tool for Ferry\nYou need to install ferryctl for each cluster\n https://github.com/ferryproxy/ferry/releases\nInstall Tunnel #  Tunnel needs to be installed for each cluster\nClusters that support LoadBalancer #  As in each public cloud environment\nferryctl data-plane init --tunnel-service-type=LoadBalancer Other #  such as Kind or private cloud environments\nwill use NodePort to expose port 31087 by default\nferryctl data-plane init "},{"id":10,"href":"/docs/principle/","title":"Technology Principle","section":"Docs","content":"Technology Principle #  Communication and penetration #  Ferry-Tunnel uses the capabilities of the ssh protocol for communication and penetration between Ferry-Tunnel\nThe following capabilities are primarily used\n  direct-tcpip  tcpip-forward  direct-streamlocal  streamlocal-forward  There are two core points\n Listen to a local port, connect to the Ferry-Tunnel on the other side, and forward all connections through it Connecting to the peer Ferry-Tunnel and listening to a port, and forwarding connections from the listening port to the local  Service Discovery #  Each exported service port will be assigned a port in the Ferry-Tunnel of the imported cluster\nFerry will create a port in the imported cluster for the Headless Service to point to the Ferry-Tunnel\u0026rsquo;s corresponding service in this cluster\n"},{"id":11,"href":"/docs/user/with-service-mesh/","title":"With Service Mesh","section":"Docs","content":"With Service Mesh #  As verified in Istio, Ferry fits perfectly as long as Sidecar is not injected into the ferry-tunnel\n"}]